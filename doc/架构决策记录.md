# 架构决策记录 (ADR)

## 什么是 ADR？

架构决策记录 (Architecture Decision Records, ADR) 是记录对项目有重大影响的架构决策的文档。每个ADR描述了我们面临的上下文、决策以及结果，帮助团队理解为什么以特定方式设计系统。

## ADR 列表

- [ADR-0001: 微服务架构选择](#adr-0001-微服务架构选择)
- [ADR-0002: gRPC 作为服务间通信协议](#adr-0002-grpc-作为服务间通信协议)
- [ADR-0003: 领域驱动设计 (DDD)](#adr-0003-领域驱动设计-ddd)
- [ADR-0004: 依赖注入模式](#adr-0004-依赖注入模式)
- [ADR-0005: 数据一致性策略](#adr-0005-数据一致性策略)

---

## ADR-0001: 微服务架构选择

### 状态
已接受

### 背景
在设计电商系统时，我们需要决定整体系统架构。考虑到系统规模、业务复杂性和未来扩展性，我们需要在单体架构和微服务架构之间做出选择。

### 决策
我们决定采用微服务架构，将系统拆分为以下核心服务：
- 用户服务 (user_srv)
- 商品服务 (goods_srv)
- 订单服务 (order_srv)
- 库存服务 (inventory_srv)
- 用户操作服务 (userop_srv)

### 原因
1. **独立扩展**: 各服务可根据实际负载独立扩展
2. **技术异构性**: 不同服务可以使用最适合其业务特性的技术栈
3. **容错性**: 单个服务故障不会导致整个系统崩溃
4. **开发效率**: 多团队可并行开发不同服务
5. **按业务边界划分**: 符合DDD思想，每个服务对应清晰的业务领域

### 影响
1. **分布式系统复杂性**: 需要处理服务发现、负载均衡、故障处理等
2. **数据一致性**: 跨服务事务变得复杂
3. **运维成本**: 需要更复杂的部署、监控和排障机制
4. **测试难度**: 跨服务集成测试更加复杂

### 实施计划
1. 定义服务边界和职责
2. 设计服务间通信协议
3. 选择合适的服务注册与发现机制
4. 实现基础设施层
5. 逐步实现各微服务

---

## ADR-0002: gRPC 作为服务间通信协议

### 状态
已接受

### 背景
微服务架构需要高效、可靠的服务间通信机制。我们需要在REST API、GraphQL、gRPC等选项中进行选择。

### 决策
采用gRPC作为服务间通信的主要协议，同时在API网关层提供RESTful接口给前端。

### 原因
1. **性能**: gRPC基于HTTP/2和Protocol Buffers，性能优于传统REST API
2. **强类型接口**: Protocol Buffers提供了强类型定义，减少运行时错误
3. **代码生成**: 自动生成客户端和服务端代码，减少样板代码
4. **双向流**: 支持服务器推送和客户端流式处理
5. **跨语言支持**: 支持多种编程语言，便于未来集成不同语言的服务

### 影响
1. **学习曲线**: 团队需要学习Protocol Buffers和gRPC
2. **调试复杂性**: 相比REST API，gRPC调试工具较少
3. **网关层转换**: 需要在API网关层将gRPC转换为REST API

### 实施计划
1. 定义所有服务的Protocol Buffers文件
2. 设置gRPC代码生成流程
3. 实现基础gRPC服务框架
4. 在API网关层实现gRPC到REST的转换

---

## ADR-0003: 领域驱动设计 (DDD)

### 状态
已接受

### 背景
电商系统业务逻辑复杂，需要清晰的架构来管理这种复杂性。我们需要选择适合的架构模式来组织代码和业务逻辑。

### 决策
采用领域驱动设计(DDD)作为核心服务的架构模式，将业务逻辑组织为以下层次：
- 领域层 (Domain Layer)
- 应用层 (Application Layer)
- 基础设施层 (Infrastructure Layer)
- 接口层 (Interface Layer)

### 原因
1. **业务复杂性管理**: DDD专注于核心业务逻辑，有助于管理复杂业务规则
2. **业务与技术分离**: 领域模型独立于技术实现，提高代码可维护性
3. **通用语言**: 促进开发团队和业务专家使用统一语言交流
4. **模块化**: 清晰的边界有助于代码模块化
5. **测试友好**: 便于编写单元测试和集成测试

### 影响
1. **设计复杂性**: 初始设计阶段需要更多时间
2. **学习曲线**: 团队需要理解DDD概念和模式
3. **过度设计风险**: 简单业务场景可能不需要完整DDD

### 实施计划
1. 进行领域建模，识别核心实体、值对象和聚合
2. 定义领域事件和服务
3. 实现仓储接口和实现
4. 建立应用服务层
5. 开发基础设施和适配器

---

## ADR-0004: 依赖注入模式

### 状态
已接受

### 背景
良好的代码组织和依赖管理对于维护复杂系统至关重要。我们需要决定如何管理组件间的依赖关系。

### 决策
采用依赖注入模式，并使用Google Wire工具实现依赖注入。

### 原因
1. **松耦合**: 减少组件间的直接依赖
2. **测试性**: 便于创建模拟对象进行单元测试
3. **灵活性**: 运行时可替换具体实现
4. **配置集中**: 所有依赖在一处配置，提高可维护性
5. **编译时验证**: Wire在编译时生成依赖图，避免运行时错误

### 影响
1. **额外配置**: 需要编写额外的Wire配置代码
2. **构建复杂性**: 增加构建流程复杂性
3. **学习成本**: 团队需要学习依赖注入模式和Wire工具

### 实施计划
1. 设计接口优先的组件结构
2. 安装并配置Wire工具
3. 创建各服务的依赖注入配置
4. 重构现有代码以使用依赖注入

---

## ADR-0005: 数据一致性策略

### 状态
已接受

### 背景
在微服务架构中，跨服务的事务处理是一个挑战。我们需要决定如何在保持数据一致性的同时不牺牲系统可用性。

### 决策
采用最终一致性模型，使用异步消息和补偿事务来处理跨服务数据一致性。具体实现使用以下模式：
- 事务消息模式
- Saga模式
- 补偿事务

### 原因
1. **可用性优先**: 强一致性会降低系统可用性和性能
2. **业务特性**: 电商系统中，大部分场景可以接受短暂的不一致状态
3. **扩展性**: 最终一致性模型更适合分布式系统扩展
4. **实际可行性**: 完全的分布式事务难以实现和维护

### 影响
1. **编程复杂性**: 需要额外的代码处理不一致状态和补偿逻辑
2. **状态管理**: 需要跟踪事务和补偿状态
3. **错误处理**: 需要更复杂的错误处理机制
4. **用户体验**: 可能需要向用户呈现"处理中"状态

### 实施计划
1. 识别关键事务流程
2. 设计每个事务流程的补偿机制
3. 实现消息可靠投递
4. 开发状态跟踪和管理系统
5. 增加监控和告警机制

## 如何贡献新的 ADR

1. 创建新的 ADR 文档，使用下一个可用编号
2. 遵循上述模板格式
3. 提交 PR 并征求团队反馈
4. 根据讨论修改 ADR
5. 合并 ADR 到主分支