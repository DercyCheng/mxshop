# Shop 开发者指南

本指南为 Shop 电商微服务系统的开发者提供详细的开发规范、代码示例和最佳实践。

## 开发环境设置

### 前置要求

- Go 1.16+
- Docker 和 Docker Compose 
- MySQL 8.0+
- Redis 6.0+
- IDE 推荐: GoLand 或 VS Code

### 本地开发环境配置

1. 克隆仓库

```bash
git clone https://github.com/username/shop.git
cd shop
```

2. 启动基础设施

```bash
cd scripts
./run.py start_infra
```

3. 创建并初始化数据库

```bash
mysql -h 127.0.0.1 -u root -p < scripts/init.sql
```

4. 运行特定服务

```bash
cd shop_srv/user_srv
export NACOS_HOST=127.0.0.1
go run cmd/server/main.go
```

## 项目架构

Shop 采用典型的 DDD (领域驱动设计) 架构，每个微服务遵循以下层次结构:

```
service_name/
├── cmd/                # 应用程序入口
│   └── server/         # 服务启动逻辑
├── domain/             # 领域层 - 核心业务逻辑
├── internal/           # 内部实现
├── pkg/                # 可共享的包
└── tests/              # 测试文件
```

## 代码规范

### 命名规范

| 类型 | 规范 | 示例 |
|------|------|------|
| 变量 | 驼峰式 | `userID`, `orderList` |
| 常量 | 全大写+下划线 | `MAX_RETRY_COUNT` |
| 接口 | "er"结尾 | `UserServicer` |
| 文件名 | 小写+下划线 | `user_service.go` |
| 包名 | 简短、小写、无下划线 | `handler`, `models` |

### 错误处理

Shop 采用标准的 Go 错误处理模式:

```go
func DoSomething() (Result, error) {
    result, err := someOperation()
    if err != nil {
        // 包装错误，提供上下文
        return nil, fmt.Errorf("failed to perform operation: %w", err)
    }
    return result, nil
}
```

使用 `errors.Is()` 和 `errors.As()` 进行错误比较:

```go
var notFoundErr *NotFoundError

if errors.Is(err, io.EOF) {
    // 处理EOF错误
}

if errors.As(err, &notFoundErr) {
    // 处理NotFoundError
}
```

### 日志规范

使用结构化日志，并包含足够的上下文信息:

```go
logger.Info("processing order",
    zap.Int64("order_id", order.ID),
    zap.String("user_id", order.UserID),
    zap.Float64("amount", order.Amount))
```

## 微服务开发指南

### 添加新服务

以下是添加新服务的步骤:

1. 在 shop_srv 目录下创建新的服务目录

```bash
mkdir -p shop_srv/new_service_srv/{cmd/server,domain,internal,pkg,tests}
```

2. 编写 proto 文件定义服务接口

```protobuf
syntax = "proto3";

package new_service;
option go_package = ".;proto";

service NewService {
    rpc GetSomething(GetSomethingRequest) returns (GetSomethingResponse);
}

message GetSomethingRequest {
    string id = 1;
}

message GetSomethingResponse {
    string data = 1;
}
```

3. 生成 gRPC 代码

```bash
protoc --go_out=. --go-grpc_out=. new_service.proto
```

4. 定义领域接口

```go
// domain/new_service.go
package domain

type NewServicer interface {
    GetSomething(id string) (string, error)
}
```

5. 实现具体的接口实现类

```go
// internal/service/new_service.go
package service

import "shop/shop_srv/new_service_srv/domain"

type NewService struct {
    // dependencies
}

func NewNewService() domain.NewServicer {
    return &NewService{}
}

func (s *NewService) GetSomething(id string) (string, error) {
    // implementation
    return "data for " + id, nil
}
```

6. 使用 Wire 配置依赖注入

```go
// internal/di/wire.go
package di

import (
    "github.com/google/wire"
    "shop/shop_srv/new_service_srv/internal/service"
)

func InitializeService() *service.NewService {
    wire.Build(service.NewNewService)
    return nil
}
```

7. 在 shop_web 目录下创建对应的 API 层

### 数据库操作示例

使用 GORM 进行数据库操作:

```go
// 定义模型
type User struct {
    gorm.Model
    Mobile   string `gorm:"index:idx_mobile;unique;type:varchar(11);not null"`
    Password string `gorm:"type:varchar(100);not null"`
    Nickname string `gorm:"type:varchar(20)"`
    Birthday *time.Time `gorm:"type:datetime"`
    Gender   string `gorm:"column:gender;default:male;type:varchar(6) comment 'female表示女, male表示男'"`
    Role     int `gorm:"default:1;comment '1表示普通用户, 2表示管理员'"`
}

// 创建记录
user := User{Mobile: "13800138000", Password: "password", Nickname: "张三"}
result := db.Create(&user)
if result.Error != nil {
    // 处理错误
}
fmt.Println(user.ID) // 返回插入数据的主键

// 查询记录
var user User
db.First(&user, 1) // 根据主键查找
db.First(&user, "mobile = ?", "13800138000") // 根据条件查找

// 更新记录
db.Model(&user).Updates(User{Nickname: "李四", Gender: "female"})

// 删除记录
db.Delete(&user, 1)
```

### gRPC 服务实现示例

```go
// cmd/server/main.go
package main

import (
    "log"
    "net"
    
    "google.golang.org/grpc"
    "shop/shop_srv/new_service_srv/internal/di"
    "shop/shop_srv/new_service_srv/proto"
)

func main() {
    // 初始化服务
    service := di.InitializeService()
    
    // 创建gRPC服务器
    s := grpc.NewServer()
    proto.RegisterNewServiceServer(s, service)
    
    // 监听端口
    lis, err := net.Listen("tcp", ":50051")
    if err != nil {
        log.Fatalf("failed to listen: %v", err)
    }
    
    // 启动服务
    if err := s.Serve(lis); err != nil {
        log.Fatalf("failed to serve: %v", err)
    }
}
```

### 配置管理

使用 Nacos 管理配置:

```go
// 连接Nacos
configClient, err := clients.CreateConfigClient(map[string]interface{}{
    "serverConfigs": []constant.ServerConfig{
        {
            IpAddr: "127.0.0.1",
            Port:   8848,
        },
    },
    "clientConfig": constant.ClientConfig{
        NamespaceId:         "public",
        TimeoutMs:           5000,
        NotLoadCacheAtStart: true,
        LogDir:              "tmp/nacos/log",
        CacheDir:            "tmp/nacos/cache",
        LogLevel:            "debug",
    },
})

// 读取配置
content, err := configClient.GetConfig(vo.ConfigParam{
    DataId: "user-srv",
    Group:  "dev"
})

// 监听配置变更
configClient.ListenConfig(vo.ConfigParam{
    DataId: "user-srv",
    Group:  "dev",
    OnChange: func(namespace, group, dataId, data string) {
        // 处理配置变更
        fmt.Println("配置变更: " + data)
    },
})
```

## 测试指南

### 单元测试

每个函数应该有对应的单元测试，重点测试边界条件:

```go
func TestGetUser(t *testing.T) {
    // 创建Mock对象
    mockRepo := new(MockUserRepository)
    mockRepo.On("GetByID", 1).Return(&domain.User{ID: 1, Name: "Test"}, nil)
    mockRepo.On("GetByID", 2).Return(nil, errors.New("user not found"))
    
    // 创建待测试的服务
    service := NewUserService(mockRepo)
    
    // 测试成功情况
    user, err := service.GetUser(1)
    assert.NoError(t, err)
    assert.Equal(t, 1, user.ID)
    assert.Equal(t, "Test", user.Name)
    
    // 测试失败情况
    user, err = service.GetUser(2)
    assert.Error(t, err)
    assert.Nil(t, user)
}
```

### 集成测试

测试服务之间的交互:

```go
func TestOrderCreation(t *testing.T) {
    // 初始化测试环境
    orderSrv := initOrderService(t)
    inventorySrv := initInventoryService(t)
    
    // 创建订单
    orderReq := &proto.CreateOrderRequest{
        UserId:  1,
        Address: "Test Address",
        Items: []*proto.OrderItem{
            {GoodsId: 1, Num: 2},
        },
    }
    
    // 发起请求
    orderResp, err := orderSrv.CreateOrder(context.Background(), orderReq)
    require.NoError(t, err)
    require.NotEmpty(t, orderResp.Id)
    
    // 验证库存变更
    invReq := &proto.InventoryDetailRequest{GoodsId: 1}
    invResp, err := inventorySrv.GetInventoryDetail(context.Background(), invReq)
    require.NoError(t, err)
    
    // 断言库存已减少
    expectedStock := 98 // 假设初始库存为100
    assert.Equal(t, int32(expectedStock), invResp.Stocks)
}
```

## 部署指南

### Docker 部署

使用提供的 Dockerfile 和 docker-compose.yml 进行部署:

```bash
# 构建镜像
docker build -t shop-user-srv -f Dockerfile .

# 启动服务
docker-compose up -d
```

### Kubernetes 部署

使用 Helm 或直接应用 Kubernetes 配置:

```bash
kubectl apply -f deploy/k8s/services/user-srv.yaml
```

## 故障排除

1. **服务无法启动**
   - 检查配置文件是否正确
   - 确认数据库连接是否正常
   - 查看日志获取详细错误信息

2. **服务间调用失败**
   - 检查服务发现是否正常工作
   - 验证目标服务是否健康
   - 检查网络连接和防火墙设置

3. **性能问题**
   - 使用 pprof 进行性能分析
   - 检查数据库查询效率
   - 监控系统资源使用情况

## 常见问题 (FAQ)

1. **如何添加新的API端点?**
   
   在对应的服务中添加新的 gRPC 方法，然后在 Web 层注册新的路由处理函数。

2. **如何修改数据库模型?**

   更新模型定义，然后使用 GORM 的自动迁移功能:
   ```go
   db.AutoMigrate(&models.User{})
   ```
   
3. **如何添加新的服务依赖?**

   在 Wire 配置中添加新的依赖注入规则。

4. **如何处理分布式事务?**

   使用 Saga 模式或 TCC (Try-Confirm-Cancel) 模式实现分布式事务。

## 参考资源

- [Go 编程语言规范](https://golang.org/ref/spec)
- [Effective Go](https://golang.org/doc/effective_go)
- [gRPC 官方文档](https://grpc.io/docs/)
- [GORM 官方文档](https://gorm.io/docs/)
- [Gin Web 框架](https://gin-gonic.com/docs/)
- [Wire 依赖注入](https://github.com/google/wire)

## 联系方式

如有任何问题，请联系项目维护者:

- 邮箱: dercyc@example.com
- GitHub Issues: https://github.com/username/shop/issues